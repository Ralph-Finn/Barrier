C51 COMPILER V9.52.0.0   USBHOST                                                           11/02/2017 16:18:18 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE USBHOST
OBJECT MODULE PLACED IN USBHOST.obj
COMPILER INVOKED BY: D:\Keil\C51\BIN\C51.EXE USB\USB_LIB\USBHOST.C LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\USBHOST.lst) 
                    -OBJECT(USBHOST.obj)

line level    source

   1          /********************************** (C) COPYRIGHT *******************************
   2          * File Name          : USBHOST.C
   3          * Author             : WCH
   4          * Version            : V1.0
   5          * Date               : 2017/01/20
   6          * Description        : CH554 USB Ö÷»ú½Ó¿Úº¯Êý
   7          *******************************************************************************/
   8          #include "..\..\Public\CH554.H"
   9          #include "..\..\Public\Debug.H"
  10          #include "stdio.h"
  11          #include "USBHOST.H"
  12          // #include "CH554UFR.H"                                                        //Èç¹ûÊ¹ÓÃUSBH_HUB_KM.C ´Ë
             -ÐÐÆÁ±Îµô
  13          /*******************************************************************************
  14          * Function Name  : DisableRootHubPort( )
  15          * Description    : ¹Ø±ÕHUB¶Ë¿Ú
  16          * Input          : None
  17          * Output         : None
  18          * Return         : None
  19          *******************************************************************************/
  20          void    DisableRootHubPort( )
  21          {
  22   1      #ifdef  FOR_ROOT_UDISK_ONLY
                  CH554DiskStatus = DISK_DISCONNECT;
              #endif
  25   1      #ifndef DISK_BASE_BUF_LEN
  26   1          ThisUsbDev.DeviceStatus = ROOT_DEV_DISCONNECT;
  27   1          ThisUsbDev.DeviceAddress = 0x00;
  28   1      #endif
  29   1      }
  30          /*******************************************************************************
  31          * Function Name  : AnalyzeRootHub(void)
  32          * Description    : ·ÖÎöROOT-HUB×´Ì¬,´¦ÀíROOT-HUB¶Ë¿ÚµÄÉè±¸²å°ÎÊÂ¼þ
  33                             Èç¹ûÉè±¸°Î³ö,º¯ÊýÖÐµ÷ÓÃDisableRootHubPort()º¯Êý,½«¶Ë¿Ú¹Ø±Õ,²åÈëÊÂ¼þ,ÖÃÏàÓ¦¶Ë¿ÚµÄ×´Ì¬Î»
  34          * Input          : None
  35          * Output         : None
  36          * Return         : ·µ»ØERR_SUCCESSÎªÃ»ÓÐÇé¿ö,·µ»ØERR_USB_CONNECTÎª¼ì²âµ½ÐÂÁ¬½Ó,·µ»ØERR_USB_DISCONÎª¼ì²âµ½¶
             -Ï¿ª
  37          *******************************************************************************/
  38          UINT8   AnalyzeRootHub( void )
  39          {
  40   1          UINT8   s;
  41   1          s = ERR_SUCCESS;
  42   1          if ( USB_MIS_ST & bUMS_DEV_ATTACH )                                          // Éè±¸´æÔÚ
  43   1          {
  44   2      #ifdef DISK_BASE_BUF_LEN
                      if ( CH554DiskStatus == DISK_DISCONNECT
              #else
  47   2              if ( ThisUsbDev.DeviceStatus == ROOT_DEV_DISCONNECT                        // ¼ì²âµ½ÓÐÉè±¸²åÈë
  48   2      #endif
  49   2                      || ( UHOST_CTRL & bUH_PORT_EN ) == 0x00 )                                // ¼ì²âµ½ÓÐÉè±¸²å
             -Èë,µ«ÉÐÎ´ÔÊÐí,ËµÃ÷ÊÇ¸Õ²åÈë
  50   2              {
  51   3                  DisableRootHubPort( );                                                   // ¹Ø±Õ¶Ë¿Ú
C51 COMPILER V9.52.0.0   USBHOST                                                           11/02/2017 16:18:18 PAGE 2   

  52   3      #ifdef DISK_BASE_BUF_LEN
                          CH554DiskStatus = DISK_CONNECT;
              #else
  55   3      //      ThisUsbDev.DeviceSpeed = USB_HUB_ST & bUHS_DM_LEVEL ? 0 : 1;
  56   3                  ThisUsbDev.DeviceStatus = ROOT_DEV_CONNECTED;                            //ÖÃÁ¬½Ó±êÖ¾
  57   3      #endif
  58   3      #if DE_PRINTF
  59   3                  printf( "USB dev in\n" );
  60   3      #endif
  61   3                  s = ERR_USB_CONNECT;
  62   3              }
  63   2          }
  64   1      #ifdef DISK_BASE_BUF_LEN
                  else if ( CH554DiskStatus >= DISK_CONNECT )
                  {
              #else
  68   1          else if ( ThisUsbDev.DeviceStatus >= ROOT_DEV_CONNECTED )                    //¼ì²âµ½Éè±¸°Î³ö
  69   1          {
  70   2      #endif
  71   2              DisableRootHubPort( );                                                     // ¹Ø±Õ¶Ë¿Ú
  72   2      #if DE_PRINTF
  73   2              printf( "USB dev out\n" );
  74   2      #endif
  75   2              if ( s == ERR_SUCCESS )
  76   2              {
  77   3                  s = ERR_USB_DISCON;
  78   3              }
  79   2          }
  80   1      //  UIF_DETECT = 0;                                                            // ÇåÖÐ¶Ï±êÖ¾
  81   1          return( s );
  82   1      }
  83          /*******************************************************************************
  84          * Function Name  : SetHostUsbAddr
  85          * Description    : ÉèÖÃUSBÖ÷»úµ±Ç°²Ù×÷µÄUSBÉè±¸µØÖ·
  86          * Input          : UINT8 addr
  87          * Output         : None
  88          * Return         : None
  89          *******************************************************************************/
  90          void    SetHostUsbAddr( UINT8 addr )
  91          {
  92   1          USB_DEV_AD = USB_DEV_AD & bUDA_GP_BIT | addr & 0x7F;
  93   1      }
  94          #ifndef FOR_ROOT_UDISK_ONLY
  95          /*******************************************************************************
  96          * Function Name  : SetUsbSpeed
  97          * Description    : ÉèÖÃµ±Ç°USBËÙ¶È
  98          * Input          : UINT8 FullSpeed
  99          * Output         : None
 100          * Return         : None
 101          *******************************************************************************/
 102          void    SetUsbSpeed( UINT8 FullSpeed )
 103          {
 104   1          if ( FullSpeed )                                                           // È«ËÙ
 105   1          {
 106   2              USB_CTRL &= ~ bUC_LOW_SPEED;                                           // È«ËÙ
 107   2              UH_SETUP &= ~ bUH_PRE_PID_EN;                                          // ½ûÖ¹PRE PID
 108   2          }
 109   1          else
 110   1          {
 111   2              USB_CTRL |= bUC_LOW_SPEED;                                             // µÍËÙ
 112   2          }
 113   1      }
C51 COMPILER V9.52.0.0   USBHOST                                                           11/02/2017 16:18:18 PAGE 3   

 114          #endif
 115          /*******************************************************************************
 116          * Function Name  : ResetRootHubPort( )
 117          * Description    : ¼ì²âµ½Éè±¸ºó,¸´Î»×ÜÏß,ÎªÃ¶¾ÙÉè±¸×¼±¸,ÉèÖÃÎªÄ¬ÈÏÎªÈ«ËÙ
 118          * Input          : None
 119          * Output         : None
 120          * Return         : None
 121          *******************************************************************************/
 122          void    ResetRootHubPort( )
 123          {
 124   1          UsbDevEndp0Size = DEFAULT_ENDP0_SIZE;                                      //USBÉè±¸µÄ¶Ëµã0µÄ×î´ó°ü³ß´
             -ç
 125   1          SetHostUsbAddr( 0x00 );
 126   1          SetUsbSpeed( 1 );                                                          // Ä¬ÈÏÎªÈ«ËÙ
 127   1          UHOST_CTRL = UHOST_CTRL & ~ bUH_LOW_SPEED | bUH_BUS_RESET;                 // Ä¬ÈÏÎªÈ«ËÙ,¿ªÊ¼¸´Î»
 128   1          mDelaymS( 10 );                                                             // ¸´Î»Ê±¼ä10mSµ½20mS
 129   1          UHOST_CTRL = UHOST_CTRL & ~ bUH_BUS_RESET;                                 // ½áÊø¸´Î»
 130   1          mDelayuS( 250 );
 131   1          UIF_DETECT = 0;                                                            // ÇåÖÐ¶Ï±êÖ¾
 132   1      }
 133          /*******************************************************************************
 134          * Function Name  : EnableRootHubPort( )
 135          * Description    : Ê¹ÄÜROOT-HUB¶Ë¿Ú,ÏàÓ¦µÄbUH_PORT_ENÖÃ1¿ªÆô¶Ë¿Ú,Éè±¸¶Ï¿ª¿ÉÄÜµ¼ÖÂ·µ»ØÊ§°Ü
 136          * Input          : None
 137          * Output         : None
 138          * Return         : ·µ»ØERR_SUCCESSÎª¼ì²âµ½ÐÂÁ¬½Ó,·µ»ØERR_USB_DISCONÎªÎÞÁ¬½Ó
 139          *******************************************************************************/
 140          UINT8   EnableRootHubPort( )
 141          {
 142   1      #ifdef DISK_BASE_BUF_LEN
                  if ( CH554DiskStatus < DISK_CONNECT )
                  {
                      CH554DiskStatus = DISK_CONNECT;
                  }
              #else
 148   1          if ( ThisUsbDev.DeviceStatus < ROOT_DEV_CONNECTED )
 149   1          {
 150   2              ThisUsbDev.DeviceStatus = ROOT_DEV_CONNECTED;
 151   2          }
 152   1      #endif
 153   1          if ( USB_MIS_ST & bUMS_DEV_ATTACH )                                          // ÓÐÉè±¸
 154   1          {
 155   2      #ifndef DISK_BASE_BUF_LEN
 156   2              if ( ( UHOST_CTRL & bUH_PORT_EN ) == 0x00 )                                // ÉÐÎ´Ê¹ÄÜ
 157   2              {
 158   3                  ThisUsbDev.DeviceSpeed = USB_MIS_ST & bUMS_DM_LEVEL ? 0 : 1;
 159   3                  if ( ThisUsbDev.DeviceSpeed == 0 )
 160   3                  {
 161   4                      UHOST_CTRL |= bUH_LOW_SPEED;    // µÍËÙ
 162   4                  }
 163   3              }
 164   2      #endif
 165   2              USB_CTRL |= bUC_DMA_EN;                                                    // Æô¶¯USBÖ÷»ú¼°DMA,ÔÚÖ
             -Ð¶Ï±êÖ¾Î´Çå³ýÇ°×Ô¶¯ÔÝÍ£
 166   2              UH_SETUP = bUH_SOF_EN;
 167   2              UHOST_CTRL |= bUH_PORT_EN;                                                 //Ê¹ÄÜHUB¶Ë¿Ú
 168   2              return( ERR_SUCCESS );
 169   2          }
 170   1          return( ERR_USB_DISCON );
 171   1      }
 172          #ifndef DISK_BASE_BUF_LEN
 173          /*******************************************************************************
C51 COMPILER V9.52.0.0   USBHOST                                                           11/02/2017 16:18:18 PAGE 4   

 174          * Function Name  : SelectHubPort( UINT8 HubPortIndex )
 175          * Description    : Ñ¡¶¨ÐèÒª²Ù×÷µÄHUB¿Ú
 176          * Input          : UINT8 HubPortIndex Ñ¡Ôñ²Ù×÷Ö¸¶¨µÄROOT-HUB¶Ë¿ÚµÄÍâ²¿HUBµÄÖ¸¶¨¶Ë¿Ú
 177          * Output         : None
 178          * Return         : None
 179          *******************************************************************************/
 180          void    SelectHubPort( UINT8 HubPortIndex )  
 181          {
 182   1          if ( HubPortIndex )                                                        // Ñ¡Ôñ²Ù×÷Ö¸¶¨µÄROOT-HUB¶Ë
             -¿ÚµÄÍâ²¿HUBµÄÖ¸¶¨¶Ë¿Ú
 183   1          {
 184   2              SetHostUsbAddr( DevOnHubPort[HubPortIndex-1].DeviceAddress );          // ÉèÖÃUSBÖ÷»úµ±Ç°²Ù×÷µÄUSB
             -Éè±¸µØÖ·
 185   2              if ( DevOnHubPort[HubPortIndex-1].DeviceSpeed == 0 )                   // Í¨¹ýÍâ²¿HUBÓëµÍËÙUSBÉè±¸
             -Í¨Ñ¶ÐèÒªÇ°ÖÃID
 186   2              {
 187   3                  UH_SETUP |= bUH_PRE_PID_EN;                                        // ÆôÓÃPRE PID
 188   3              }
 189   2              SetUsbSpeed( DevOnHubPort[HubPortIndex-1].DeviceSpeed );               // ÉèÖÃµ±Ç°USBËÙ¶È
 190   2          }
 191   1          else                                                                       
 192   1          {
 193   2              SetHostUsbAddr( ThisUsbDev.DeviceAddress );                            // ÉèÖÃUSBÖ÷»úµ±Ç°²Ù×÷µÄUSB
             -Éè±¸µØÖ·
 194   2              SetUsbSpeed( ThisUsbDev.DeviceSpeed );                                 // ÉèÖÃUSBÉè±¸µÄËÙ¶È
 195   2          }
 196   1      }
 197          #endif
 198          /*******************************************************************************
 199          * Function Name  : WaitUSB_Interrupt
 200          * Description    : µÈ´ýUSBÖÐ¶Ï
 201          * Input          : None
 202          * Output         : None
 203          * Return         : ·µ»ØERR_SUCCESS Êý¾Ý½ÓÊÕ»òÕß·¢ËÍ³É¹¦
 204                             ERR_USB_UNKNOWN Êý¾Ý½ÓÊÕ»òÕß·¢ËÍÊ§°Ü
 205          *******************************************************************************/
 206          UINT8   WaitUSB_Interrupt( void )
 207          {
 208   1          UINT16  i;
 209   1          for ( i = WAIT_USB_TOUT_200US; i != 0 && UIF_TRANSFER == 0; i -- )
 210   1          {
 211   2              ;
 212   2          }
 213   1          return( UIF_TRANSFER ? ERR_SUCCESS : ERR_USB_UNKNOWN );
 214   1      }
 215          /*******************************************************************************
 216          * Function Name  : USBHostTransact
 217          * Description    : CH554´«ÊäÊÂÎñ,ÊäÈëÄ¿µÄ¶ËµãµØÖ·/PIDÁîÅÆ,Í¬²½±êÖ¾,ÒÔ20uSÎªµ¥Î»µÄNAKÖØÊÔ×ÜÊ±¼ä(0Ôò²»ÖØÊÔ,0
             -xFFFFÎÞÏÞÖØÊÔ),·µ»Ø0³É¹¦,³¬Ê±/³ö´íÖØÊÔ
 218                             ±¾×Ó³ÌÐò×ÅÖØÓÚÒ×Àí½â,¶øÔÚÊµ¼ÊÓ¦ÓÃÖÐ,ÎªÁËÌá¹©ÔËÐÐËÙ¶È,Ó¦¸Ã¶Ô±¾×Ó³ÌÐò´úÂë½øÐÐÓÅ»¯
 219          * Input          : UINT8 endp_pid ÁîÅÆºÍµØÖ·  endp_pid: ¸ß4Î»ÊÇtoken_pidÁîÅÆ, µÍ4Î»ÊÇ¶ËµãµØÖ·
 220                             UINT8 tog      Í¬²½±êÖ¾
 221                             UINT16 timeout ³¬Ê±Ê±¼ä
 222          * Output         : None
 223          * Return         : ERR_USB_UNKNOWN ³¬Ê±£¬¿ÉÄÜÓ²¼þÒì³£
 224                             ERR_USB_DISCON  Éè±¸¶Ï¿ª
 225                             ERR_USB_CONNECT Éè±¸Á¬½Ó
 226                             ERR_SUCCESS     ´«ÊäÍê³É
 227          *******************************************************************************/
 228          UINT8   USBHostTransact( UINT8 endp_pid, UINT8 tog, UINT16 timeout )
 229          {
 230   1      //  UINT8   TransRetry;
C51 COMPILER V9.52.0.0   USBHOST                                                           11/02/2017 16:18:18 PAGE 5   

 231   1      #define TransRetry  UEP0_T_LEN                                                 // ½ÚÔ¼ÄÚ´æ
 232   1          UINT8   s, r;
 233   1          UINT16  i;
 234   1          UH_RX_CTRL = UH_TX_CTRL = tog;
 235   1          TransRetry = 0;
 236   1          do
 237   1          {
 238   2              UH_EP_PID = endp_pid;                                                      // Ö¸¶¨ÁîÅÆPIDºÍÄ¿µÄ¶Ëµ
             -ãºÅ
 239   2              UIF_TRANSFER = 0;                                                          // ÔÊÐí´«Êä
 240   2      //  s = WaitUSB_Interrupt( );
 241   2              for ( i = WAIT_USB_TOUT_200US; i != 0 && UIF_TRANSFER == 0; i -- )
 242   2              {
 243   3                  ;
 244   3              }
 245   2              UH_EP_PID = 0x00;                                                          // Í£Ö¹USB´«Êä
 246   2      //  if ( s != ERR_SUCCESS ) return( s );  // ÖÐ¶Ï³¬Ê±,¿ÉÄÜÊÇÓ²¼þÒì³£
 247   2              if ( UIF_TRANSFER == 0 )
 248   2              {
 249   3                  return( ERR_USB_UNKNOWN );
 250   3              }
 251   2              if ( UIF_DETECT )                                                          // USBÉè±¸²å°ÎÊÂ¼þ
 252   2              {
 253   3      //          mDelayuS( 200 );                                                       // µÈ´ý´«ÊäÍê³É
 254   3                  UIF_DETECT = 0;                                                          // ÇåÖÐ¶Ï±êÖ¾
 255   3                  s = AnalyzeRootHub( );                                                   // ·ÖÎöROOT-HUB×´Ì¬
 256   3                  if ( s == ERR_USB_CONNECT )
 257   3                  {
 258   4                      FoundNewDev = 1;
 259   4                  }
 260   3      #ifdef DISK_BASE_BUF_LEN
                          if ( CH554DiskStatus == DISK_DISCONNECT )
                          {
                              return( ERR_USB_DISCON );    // USBÉè±¸¶Ï¿ªÊÂ¼þ
                          }
                          if ( CH554DiskStatus == DISK_CONNECT )
                          {
                              return( ERR_USB_CONNECT );    // USBÉè±¸Á¬½ÓÊÂ¼þ
                          }
              #else
 270   3                  if ( ThisUsbDev.DeviceStatus == ROOT_DEV_DISCONNECT )
 271   3                  {
 272   4                      return( ERR_USB_DISCON );    // USBÉè±¸¶Ï¿ªÊÂ¼þ
 273   4                  }
 274   3                  if ( ThisUsbDev.DeviceStatus == ROOT_DEV_CONNECTED )
 275   3                  {
 276   4                      return( ERR_USB_CONNECT );    // USBÉè±¸Á¬½ÓÊÂ¼þ
 277   4                  }
 278   3      #endif
 279   3                  mDelayuS( 200 );  // µÈ´ý´«ÊäÍê³É
 280   3              }
 281   2              if ( UIF_TRANSFER )    // ´«ÊäÍê³É
 282   2              {
 283   3                  if ( U_TOG_OK )
 284   3                  {
 285   4                      return( ERR_SUCCESS );
 286   4                  }
 287   3                  r = USB_INT_ST & MASK_UIS_H_RES;  // USBÉè±¸Ó¦´ð×´Ì¬
 288   3                  if ( r == USB_PID_STALL )
 289   3                  {
 290   4                      return( r | ERR_USB_TRANSFER );
 291   4                  }
C51 COMPILER V9.52.0.0   USBHOST                                                           11/02/2017 16:18:18 PAGE 6   

 292   3                  if ( r == USB_PID_NAK )
 293   3                  {
 294   4                      if ( timeout == 0 )
 295   4                      {
 296   5                          return( r | ERR_USB_TRANSFER );
 297   5                      }
 298   4                      if ( timeout < 0xFFFF )
 299   4                      {
 300   5                          timeout --;
 301   5                      }
 302   4                      -- TransRetry;
 303   4                  }
 304   3                  else switch ( endp_pid >> 4 )
 305   3                      {
 306   4                      case USB_PID_SETUP:
 307   4                      case USB_PID_OUT:
 308   4      //                  if ( U_TOG_OK ) return( ERR_SUCCESS );
 309   4      //                  if ( r == USB_PID_ACK ) return( ERR_SUCCESS );
 310   4      //                  if ( r == USB_PID_STALL || r == USB_PID_NAK ) return( r | ERR_USB_TRANSFER );
 311   4                          if ( r )
 312   4                          {
 313   5                              return( r | ERR_USB_TRANSFER );    // ²»ÊÇ³¬Ê±/³ö´í,ÒâÍâÓ¦´ð
 314   5                          }
 315   4                          break;  // ³¬Ê±ÖØÊÔ
 316   4                      case USB_PID_IN:
 317   4      //                  if ( U_TOG_OK ) return( ERR_SUCCESS );
 318   4      //                  if ( tog ? r == USB_PID_DATA1 : r == USB_PID_DATA0 ) return( ERR_SUCCESS );
 319   4      //                  if ( r == USB_PID_STALL || r == USB_PID_NAK ) return( r | ERR_USB_TRANSFER );
 320   4                          if ( r == USB_PID_DATA0 && r == USB_PID_DATA1 )    // ²»Í¬²½ÔòÐè¶ªÆúºóÖØÊÔ
 321   4                          {
 322   5                          }  // ²»Í¬²½ÖØÊÔ
 323   4                          else if ( r )
 324   4                          {
 325   5                              return( r | ERR_USB_TRANSFER );    // ²»ÊÇ³¬Ê±/³ö´í,ÒâÍâÓ¦´ð
 326   5                          }
 327   4                          break;  // ³¬Ê±ÖØÊÔ
 328   4                      default:
 329   4                          return( ERR_USB_UNKNOWN );  // ²»¿ÉÄÜµÄÇé¿ö
 330   4                          break;
 331   4                      }
 332   3              }
 333   2              else    // ÆäËüÖÐ¶Ï,²»Ó¦¸Ã·¢ÉúµÄÇé¿ö
 334   2              {
 335   3                  USB_INT_FG = 0xFF;  /* ÇåÖÐ¶Ï±êÖ¾ */
 336   3              }
 337   2              mDelayuS( 15 );
 338   2          }
 339   1          while ( ++ TransRetry < 3 );
 340   1          return( ERR_USB_TRANSFER );  // Ó¦´ð³¬Ê±
 341   1      }
 342          /*******************************************************************************
 343          * Function Name  : HostCtrlTransfer
 344          * Description    : Ö´ÐÐ¿ØÖÆ´«Êä,8×Ö½ÚÇëÇóÂëÔÚpSetupReqÖÐ,DataBufÎª¿ÉÑ¡µÄÊÕ·¢»º³åÇø
 345          * Input          : PUINT8X DataBuf Èç¹ûÐèÒª½ÓÊÕºÍ·¢ËÍÊý¾Ý,ÄÇÃ´DataBufÐèÖ¸ÏòÓÐÐ§»º³åÇøÓÃÓÚ´æ·ÅºóÐøÊý¾Ý
 346                             PUINT8 RetLen  Êµ¼Ê³É¹¦ÊÕ·¢µÄ×Ü³¤¶È±£´æÔÚRetLenÖ¸ÏòµÄ×Ö½Ú±äÁ¿ÖÐ
 347          * Output         : None
 348          * Return         : ERR_USB_BUF_OVER IN×´Ì¬½×¶Î³ö´í
 349                             ERR_SUCCESS     Êý¾Ý½»»»³É¹¦
 350                             ÆäËû´íÎó×´Ì¬
 351          *******************************************************************************/
 352          UINT8   HostCtrlTransfer( PUINT8X DataBuf, PUINT8 RetLen )
 353          {
C51 COMPILER V9.52.0.0   USBHOST                                                           11/02/2017 16:18:18 PAGE 7   

 354   1          UINT16  RemLen  = 0;
 355   1          UINT8   s, RxLen, RxCnt, TxCnt;
 356   1          PUINT8  xdata   pBuf;
 357   1          PUINT8  xdata   pLen;
 358   1          pBuf = DataBuf;
 359   1          pLen = RetLen;
 360   1          mDelayuS( 200 );
 361   1          if ( pLen )
 362   1          {
 363   2              *pLen = 0;                                                              // Êµ¼Ê³É¹¦ÊÕ·¢µÄ×Ü³¤¶È
 364   2          }
 365   1          UH_TX_LEN = sizeof( USB_SETUP_REQ );
 366   1          s = USBHostTransact( USB_PID_SETUP << 4 | 0x00, 0x00, 200000/20 );          // SETUP½×¶Î,200mS³¬Ê±
 367   1          if ( s != ERR_SUCCESS )
 368   1          {
 369   2              return( s );
 370   2          }
 371   1          UH_RX_CTRL = UH_TX_CTRL = bUH_R_TOG | bUH_R_AUTO_TOG | bUH_T_TOG | bUH_T_AUTO_TOG;// Ä¬ÈÏDATA1
 372   1          UH_TX_LEN = 0x01;                                                           // Ä¬ÈÏÎÞÊý¾Ý¹Ê×´Ì¬½×¶ÎÎªI
             -N
 373   1          RemLen = (pSetupReq -> wLengthH << 8)|( pSetupReq -> wLengthL);
 374   1          if ( RemLen && pBuf )                                                       // ÐèÒªÊÕ·¢Êý¾Ý
 375   1          {
 376   2              if ( pSetupReq -> bRequestType & USB_REQ_TYP_IN )                       // ÊÕ
 377   2              {
 378   3                  while ( RemLen )
 379   3                  {
 380   4                      mDelayuS( 200 );
 381   4                      s = USBHostTransact( USB_PID_IN << 4 | 0x00, UH_RX_CTRL, 200000/20 );// INÊý¾Ý
 382   4                      if ( s != ERR_SUCCESS )
 383   4                      {
 384   5                          return( s );
 385   5                      }
 386   4                      RxLen = USB_RX_LEN < RemLen ? USB_RX_LEN : RemLen;
 387   4                      RemLen -= RxLen;
 388   4                      if ( pLen )
 389   4                      {
 390   5                          *pLen += RxLen;                                              // Êµ¼Ê³É¹¦ÊÕ·¢µÄ×Ü³¤¶È
 391   5                      }
 392   4      //              memcpy( pBuf, RxBuffer, RxLen );
 393   4      //              pBuf += RxLen;
 394   4                      for ( RxCnt = 0; RxCnt != RxLen; RxCnt ++ )
 395   4                      {
 396   5                          *pBuf = RxBuffer[ RxCnt ];
 397   5                          pBuf ++;
 398   5                      }
 399   4                      if ( USB_RX_LEN == 0 || ( USB_RX_LEN & ( UsbDevEndp0Size - 1 ) ) )
 400   4                      {
 401   5                          break;                                                       // ¶Ì°ü
 402   5                      }
 403   4                  }
 404   3                  UH_TX_LEN = 0x00;                                                    // ×´Ì¬½×¶ÎÎªOUT
 405   3              }
 406   2              else                                                                     // ·¢
 407   2              {
 408   3                  while ( RemLen )
 409   3                  {
 410   4                      mDelayuS( 200 );
 411   4                      UH_TX_LEN = RemLen >= UsbDevEndp0Size ? UsbDevEndp0Size : RemLen;
 412   4      //              memcpy( TxBuffer, pBuf, UH_TX_LEN );
 413   4      //              pBuf += UH_TX_LEN;
 414   4      #ifndef DISK_BASE_BUF_LEN
C51 COMPILER V9.52.0.0   USBHOST                                                           11/02/2017 16:18:18 PAGE 8   

 415   4                      if(pBuf[1] == 0x09)                                              //HIDÀàÃüÁî´¦Àí
 416   4                      {
 417   5                          Set_Port = Set_Port^1;
 418   5                          *pBuf = Set_Port;
 419   5      #if DE_PRINTF
 420   5                          printf("SET_PORT  %02X  %02X ",(UINT16)(*pBuf),(UINT16)(Set_Port));
 421   5      #endif
 422   5                      }
 423   4      #endif
 424   4                      for ( TxCnt = 0; TxCnt != UH_TX_LEN; TxCnt ++ )
 425   4                      {
 426   5                          TxBuffer[ TxCnt ] = *pBuf;
 427   5                          pBuf ++;
 428   5                      }
 429   4                      s = USBHostTransact( USB_PID_OUT << 4 | 0x00, UH_TX_CTRL, 200000/20 );// OUTÊý¾Ý
 430   4                      if ( s != ERR_SUCCESS )
 431   4                      {
 432   5                          return( s );
 433   5                      }
 434   4                      RemLen -= UH_TX_LEN;
 435   4                      if ( pLen )
 436   4                      {
 437   5                          *pLen += UH_TX_LEN;                                           // Êµ¼Ê³É¹¦ÊÕ·¢µÄ×Ü³¤¶È
 438   5                      }
 439   4                  }
 440   3      //          UH_TX_LEN = 0x01;                                                     // ×´Ì¬½×¶ÎÎªIN
 441   3              }
 442   2          }
 443   1          mDelayuS( 200 );
 444   1          s = USBHostTransact( ( UH_TX_LEN ? USB_PID_IN << 4 | 0x00: USB_PID_OUT << 4 | 0x00 ), bUH_R_TOG | bUH_
             -T_TOG, 200000/20 );  // STATUS½×¶Î
 445   1          if ( s != ERR_SUCCESS )
 446   1          {
 447   2              return( s );
 448   2          }
 449   1          if ( UH_TX_LEN == 0 )
 450   1          {
 451   2              return( ERR_SUCCESS );                                                    // ×´Ì¬OUT
 452   2          }
 453   1          if ( USB_RX_LEN == 0 )
 454   1          {
 455   2              return( ERR_SUCCESS );                                                    // ×´Ì¬IN,¼ì²éIN×´Ì¬·µ»Ø
             -Êý¾Ý³¤¶È
 456   2          }
 457   1          return( ERR_USB_BUF_OVER );                                                   // IN×´Ì¬½×¶Î´íÎó
 458   1      }
 459          /*******************************************************************************
 460          * Function Name  : CopySetupReqPkg
 461          * Description    : ¸´ÖÆ¿ØÖÆ´«ÊäµÄÇëÇó°ü
 462          * Input          : PUINT8C pReqPkt ¿ØÖÆÇëÇó°üµØÖ·
 463          * Output         : None
 464          * Return         : None
 465          *******************************************************************************/
 466          void    CopySetupReqPkg( PUINT8C pReqPkt )                                        // ¸´ÖÆ¿ØÖÆ´«ÊäµÄÇëÇó°ü
 467          {
 468   1          UINT8   i;
 469   1          for ( i = 0; i != sizeof( USB_SETUP_REQ ); i ++ )
 470   1          {
 471   2              ((PUINT8X)pSetupReq)[ i ] = *pReqPkt;
 472   2              pReqPkt ++;
 473   2          }
 474   1      }
C51 COMPILER V9.52.0.0   USBHOST                                                           11/02/2017 16:18:18 PAGE 9   

 475          /*******************************************************************************
 476          * Function Name  : CtrlGetDeviceDescr
 477          * Description    : »ñÈ¡Éè±¸ÃèÊö·û,·µ»ØÔÚTxBufferÖÐ
 478          * Input          : None
 479          * Output         : None
 480          * Return         : ERR_USB_BUF_OVER ÃèÊö·û³¤¶È´íÎó
 481                             ERR_SUCCESS      ³É¹¦
 482                             ÆäËû
 483          *******************************************************************************/
 484          UINT8   CtrlGetDeviceDescr( void )
 485          {
 486   1          UINT8   s;
 487   1          UINT8   len;
 488   1          UsbDevEndp0Size = DEFAULT_ENDP0_SIZE;
 489   1          CopySetupReqPkg( SetupGetDevDescr );
 490   1          s = HostCtrlTransfer( TxBuffer, (PUINT8)&len );                                      // Ö´ÐÐ¿ØÖÆ´«Êä
 491   1          if ( s != ERR_SUCCESS )
 492   1          {
 493   2              return( s );
 494   2          }
 495   1          UsbDevEndp0Size = ( (PXUSB_DEV_DESCR)TxBuffer ) -> bMaxPacketSize0;          // ¶Ëµã0×î´ó°ü³¤¶È,ÕâÊÇ¼ò
             -»¯´¦Àí,Õý³£Ó¦¸ÃÏÈ»ñÈ¡Ç°8×Ö½ÚºóÁ¢¼´¸üÐÂUsbDevEndp0SizeÔÙ¼ÌÐø
 496   1          if ( len < ( (PUSB_SETUP_REQ)SetupGetDevDescr ) -> wLengthL )
 497   1          {
 498   2              return( ERR_USB_BUF_OVER );                                              // ÃèÊö·û³¤¶È´íÎó
 499   2          }
 500   1          return( ERR_SUCCESS );
 501   1      }
 502          /*******************************************************************************
 503          * Function Name  : CtrlGetConfigDescr
 504          * Description    : »ñÈ¡ÅäÖÃÃèÊö·û,·µ»ØÔÚTxBufferÖÐ
 505          * Input          : None
 506          * Output         : None
 507          * Return         : ERR_USB_BUF_OVER ÃèÊö·û³¤¶È´íÎó
 508                             ERR_SUCCESS      ³É¹¦
 509                             ÆäËû
 510          *******************************************************************************/
 511          UINT8   CtrlGetConfigDescr( void )
 512          {
 513   1          UINT8   s;
 514   1          UINT8  len;
 515   1          CopySetupReqPkg( SetupGetCfgDescr );
 516   1          s = HostCtrlTransfer( TxBuffer, (PUINT8)&len );                                      // Ö´ÐÐ¿ØÖÆ´«Êä
 517   1          if ( s != ERR_SUCCESS )
 518   1          {
 519   2              return( s );
 520   2          }
 521   1          if ( len < ( (PUSB_SETUP_REQ)SetupGetCfgDescr ) -> wLengthL )
 522   1          {
 523   2              return( ERR_USB_BUF_OVER );                                              // ·µ»Ø³¤¶È´íÎó
 524   2          }
 525   1          len = ( (PXUSB_CFG_DESCR)TxBuffer ) -> wTotalLengthL;
 526   1          CopySetupReqPkg( SetupGetCfgDescr );
 527   1          pSetupReq -> wLengthL = len;                                                 // ÍêÕûÅäÖÃÃèÊö·ûµÄ×Ü³¤¶È
 528   1          s = HostCtrlTransfer( TxBuffer, (PUINT8)&len );                                      // Ö´ÐÐ¿ØÖÆ´«Êä
 529   1          if ( s != ERR_SUCCESS )
 530   1          {
 531   2              return( s );
 532   2          }
 533   1          if ( len < ( (PUSB_SETUP_REQ)SetupGetCfgDescr ) -> wLengthL || len < ( (PXUSB_CFG_DESCR)TxBuffer ) -> 
             -wTotalLengthL )
 534   1          {
C51 COMPILER V9.52.0.0   USBHOST                                                           11/02/2017 16:18:18 PAGE 10  

 535   2              return( ERR_USB_BUF_OVER );                                              // ÃèÊö·û³¤¶È´íÎó
 536   2          }
 537   1          return( ERR_SUCCESS );
 538   1      }
 539          /*******************************************************************************
 540          * Function Name  : CtrlSetUsbAddress
 541          * Description    : ÉèÖÃUSBÉè±¸µØÖ·
 542          * Input          : UINT8 addr Éè±¸µØÖ·
 543          * Output         : None
 544          * Return         : ERR_SUCCESS      ³É¹¦
 545                             ÆäËû
 546          *******************************************************************************/
 547          UINT8   CtrlSetUsbAddress( UINT8 addr )
 548          {
 549   1          UINT8   s;
 550   1          CopySetupReqPkg( SetupSetUsbAddr );
 551   1          pSetupReq -> wValueL = addr;                                                // USBÉè±¸µØÖ·
 552   1          s = HostCtrlTransfer( NULL, (PUINT8)NULL );                                         // Ö´ÐÐ¿ØÖÆ´«Êä
 553   1          if ( s != ERR_SUCCESS )
 554   1          {
 555   2              return( s );
 556   2          }
 557   1          SetHostUsbAddr( addr );                                                     // ÉèÖÃUSBÖ÷»úµ±Ç°²Ù×÷µÄUS
             -BÉè±¸µØÖ·
 558   1          mDelaymS( 10 );                                                             // µÈ´ýUSBÉè±¸Íê³É²Ù×÷
 559   1          return( ERR_SUCCESS );
 560   1      }
 561          /*******************************************************************************
 562          * Function Name  : CtrlSetUsbConfig
 563          * Description    : ÉèÖÃUSBÉè±¸ÅäÖÃ
 564          * Input          : UINT8 cfg       ÅäÖÃÖµ
 565          * Output         : None
 566          * Return         : ERR_SUCCESS      ³É¹¦
 567                             ÆäËû
 568          *******************************************************************************/
 569          UINT8   CtrlSetUsbConfig( UINT8 cfg )
 570          {
 571   1          CopySetupReqPkg( SetupSetUsbConfig );
 572   1          pSetupReq -> wValueL = cfg;                                                // USBÉè±¸ÅäÖÃ
 573   1          return( HostCtrlTransfer( NULL, (PUINT8)NULL ) );                                  // Ö´ÐÐ¿ØÖÆ´«Êä
 574   1      }
 575          /*******************************************************************************
 576          * Function Name  : CtrlClearEndpStall
 577          * Description    : Çå³ý¶ËµãSTALL
 578          * Input          : UINT8 endp       ¶ËµãµØÖ·
 579          * Output         : None
 580          * Return         : ERR_SUCCESS      ³É¹¦
 581                             ÆäËû
 582          *******************************************************************************/
 583          UINT8   CtrlClearEndpStall( UINT8 endp )
 584          {
 585   1          CopySetupReqPkg( SetupClrEndpStall );                                      // Çå³ý¶ËµãµÄ´íÎó
 586   1          pSetupReq -> wIndexL = endp;                                               // ¶ËµãµØÖ·
 587   1          return( HostCtrlTransfer( NULL, (PUINT8)NULL ) );                                  // Ö´ÐÐ¿ØÖÆ´«Êä
 588   1      }
 589          
 590          // /*******************************************************************************
 591          // * Function Name  : CtrlSetUsbIntercace
 592          // * Description    : ÉèÖÃUSBÉè±¸½Ó¿Ú
 593          // * Input          : UINT8 cfg       ÅäÖÃÖµ
 594          // * Output         : None
 595          // * Return         : ERR_SUCCESS      ³É¹¦
C51 COMPILER V9.52.0.0   USBHOST                                                           11/02/2017 16:18:18 PAGE 11  

 596          //                    ÆäËû
 597          // *******************************************************************************/
 598          // UINT8   CtrlSetUsbIntercace( UINT8 cfg )
 599          // {
 600          //     CopySetupReqPkg( SetupSetUsbInterface );
 601          //     pSetupReq -> wValueL = cfg;                                                // USBÉè±¸ÅäÖÃ
 602          //     return( HostCtrlTransfer( NULL, (PUINT8)NULL ) );                                  // Ö´ÐÐ¿ØÖÆ´«Êä
 603          // }
 604          /*******************************************************************************
 605          * Function Name  : InitRootDevice
 606          * Description    : ³õÊ¼»¯Ö¸¶¨ROOT-HUB¶Ë¿ÚµÄUSBÉè±¸
 607          * Input          : UINT8 RootHubIndex Ö¸¶¨¶Ë¿Ú£¬ÄÚÖÃHUB¶Ë¿ÚºÅ0/1
 608          * Output         : None
 609          * Return         :
 610          *******************************************************************************/
 611          UINT8   InitRootDevice( UINT8 RootHubIndex )
 612          {
 613   1          UINT8   t,i, s, cfg, dv_cls, if_cls,if_subcls,if_ptl, ifc;
 614   1          t = 0;
 615   1      #if DE_PRINTF
 616   1          printf( "Reset root hub %1d# port\n", (UINT16)RootHubIndex );
 617   1      #endif
 618   1      USBDevEnum:
 619   1          for(i=0; i<t; i++)
 620   1          {
 621   2              mDelaymS( 300 );
 622   2              if(t>10)
 623   2              {
 624   3                  return( s );
 625   3              }
 626   2          }
 627   1          ResetRootHubPort( );                                                    // ¼ì²âµ½Éè±¸ºó,¸´Î»ÏàÓ¦¶Ë¿ÚµÄ
             -USB×ÜÏß
 628   1          for ( i = 0, s = 0; i < 100; i ++ )                                     // µÈ´ýUSBÉè±¸¸´Î»ºóÖØÐÂÁ¬½Ó,1
             -00mS³¬Ê±
 629   1          {
 630   2              mDelaymS( 1 );
 631   2              if ( EnableRootHubPort( ) == ERR_SUCCESS )                          // Ê¹ÄÜROOT-HUB¶Ë¿Ú
 632   2              {
 633   3                  i = 0;
 634   3                  s ++;                                                           // ¼ÆÊ±µÈ´ýUSBÉè±¸Á¬½ÓºóÎÈ¶¨
 635   3                  if ( s > 25 )
 636   3                  {
 637   4                      break;                                                      // ÒÑ¾­ÎÈ¶¨Á¬½Ó15mS
 638   4                  }
 639   3              }
 640   2          }
 641   1          if ( i )                                                                 // ¸´Î»ºóÉè±¸Ã»ÓÐÁ¬½Ó
 642   1          {
 643   2              DisableRootHubPort( );
 644   2      #if DE_PRINTF
 645   2              printf( "Disable root hub %1d# port because of disconnect\n", (UINT16)RootHubIndex );
 646   2      #endif
 647   2      //         return( ERR_USB_DISCON );
 648   2          }
 649   1          SelectHubPort( 0 );
 650   1      #if DE_PRINTF
 651   1          printf( "GetDevDescr: " );
 652   1      #endif
 653   1          s = CtrlGetDeviceDescr( );                                               // »ñÈ¡Éè±¸ÃèÊö·û
 654   1          if ( s == ERR_SUCCESS )
 655   1          {
C51 COMPILER V9.52.0.0   USBHOST                                                           11/02/2017 16:18:18 PAGE 12  

 656   2      #if DE_PRINTF
 657   2              for ( i = 0; i < ( (PUSB_SETUP_REQ)SetupGetDevDescr ) -> wLengthL; i ++ )
 658   2              {
 659   3                  printf( "x%02X ", (UINT16)( TxBuffer[i] ) );
 660   3              }
 661   2              printf( "\n" );                                                       // ÏÔÊ¾³öÃèÊö·û
 662   2      #endif
 663   2              dv_cls = ( (PXUSB_DEV_DESCR)TxBuffer ) -> bDeviceClass;               // Éè±¸Àà´úÂë
 664   2              s = CtrlSetUsbAddress( RootHubIndex + ( (PUSB_SETUP_REQ)SetupSetUsbAddr ) -> wValueL );// ÉèÖÃUSBÉ
             -è±¸µØÖ·,¼ÓÉÏRootHubIndex¿ÉÒÔ±£Ö¤2¸öHUB¶Ë¿Ú·ÖÅä²»Í¬µÄµØÖ·
 665   2              if ( s == ERR_SUCCESS )
 666   2              {
 667   3                  ThisUsbDev.DeviceAddress = RootHubIndex + ( (PUSB_SETUP_REQ)SetupSetUsbAddr ) -> wValueL;  // 
             -±£´æUSBµØÖ·
 668   3      #if DE_PRINTF
 669   3                  printf( "GetCfgDescr: " );
 670   3      #endif
 671   3                  s = CtrlGetConfigDescr( );                                        // »ñÈ¡ÅäÖÃÃèÊö·û
 672   3                  if ( s == ERR_SUCCESS )
 673   3                  {
 674   4                      cfg = ( (PXUSB_CFG_DESCR)TxBuffer ) -> bConfigurationValue;
 675   4                      ifc = ( (PXUSB_CFG_DESCR)TxBuffer ) -> bNumInterfaces;
 676   4      #if DE_PRINTF
 677   4                      for ( i = 0; i < ( (PXUSB_CFG_DESCR)TxBuffer ) -> wTotalLengthL; i ++ )
 678   4                      {
 679   5                          printf( "x%02X ", (UINT16)( TxBuffer[i] ) );
 680   5                      }
 681   4                      printf("\n");
 682   4      #endif
 683   4                      //·ÖÎöÅäÖÃÃèÊö·û,»ñÈ¡¶ËµãÊý¾Ý/¸÷¶ËµãµØÖ·/¸÷¶Ëµã´óÐ¡µÈ,¸üÐÂ±äÁ¿endp_addrºÍendp_sizeµÈ
 684   4                      if_cls = ( (PXUSB_CFG_DESCR_LONG)TxBuffer ) -> itf_descr.bInterfaceClass;  // ½Ó¿ÚÀà´úÂë
 685   4                      /* Ôö¼Ó¶ÔadbÉè±¸µÄÖ§³Ö,·ÖÎöÊÇ·ñÓÐADB½Ó¿Ú */
 686   4                      if_subcls = ( (PXUSB_CFG_DESCR_LONG)TxBuffer ) -> itf_descr.bInterfaceSubClass;  // ½Ó¿ÚÀà
             -´úÂë
 687   4                      if_ptl = ( (PXUSB_CFG_DESCR_LONG)TxBuffer ) -> itf_descr.bInterfaceProtocol;  // ½Ó¿ÚÀà´úÂ
             -ë
 688   4                      if((if_cls!=0xFF) ||(if_subcls!=0x42) ||(if_ptl!=0x01))
 689   4                      {
 690   5      #if DE_PRINTF
 691   5                          printf( "if_cls0 %02x\n",(UINT16)if_cls );
 692   5                          printf( "if_subcls0 %02x\n",(UINT16)if_subcls );
 693   5                          printf( "if_ptl0 %02x\n",(UINT16)if_ptl );
 694   5      #endif                                                                  
 695   5                          if(ifc>1)   //ÕÒÏÂÒ»¸ö½Ó¿Ú
 696   5                          {
 697   6                              for ( i = 18; i < ( (PXUSB_CFG_DESCR)TxBuffer ) -> wTotalLengthL;  )
 698   6                              {
 699   7                                  if((TxBuffer[i]==0x09)&&(TxBuffer[i+1]==0x04))
 700   7                                  {
 701   8                                      if_cls = TxBuffer[i+5];
 702   8                                      if_subcls = TxBuffer[i+6];
 703   8                                      if_ptl = TxBuffer[i+7];
 704   8      #if DE_PRINTF
 705   8                          printf( "if_cls4 %02x\n",(UINT16)if_cls );
 706   8                          printf( "if_subcls4 %02x\n",(UINT16)if_subcls );
 707   8                          printf( "if_ptl4 %02x\n",(UINT16)if_ptl );
 708   8      #endif                                                                                                                                                                                  
 709   8                          if((if_cls==0xFF)&&(if_subcls==0x42)&&(if_ptl==0x01))       break;                                                                                                  
 710   8                                  }
 711   7                                  i+=TxBuffer[i];
 712   7                              }
 713   6                          }
C51 COMPILER V9.52.0.0   USBHOST                                                           11/02/2017 16:18:18 PAGE 13  

 714   5                      }
 715   4                      if((if_cls==0xFF) &&(if_subcls==0x42) &&(if_ptl==0x01))
 716   4                      {                                                       
 717   5                          if(TxBuffer[i+9+2]&0x80)
 718   5                          {
 719   6                              ThisUsbDev.GpVar[0] = TxBuffer[i+9+2]&0x0f;   //ÉÏ´«¶Ëµã
 720   6                              ThisUsbDev.GpVar[1] = TxBuffer[i+9+7+2];      //ÏÂ´«¶Ëµã
 721   6                          }
 722   5                          else
 723   5                          {
 724   6                              ThisUsbDev.GpVar[0] = TxBuffer[i+9+7+2]&0x0f;  //ÉÏ´«¶Ëµã
 725   6                              ThisUsbDev.GpVar[1] = TxBuffer[i+9+2];         //ÏÂ´«¶Ëµã
 726   6                          }
 727   5                          s = CtrlSetUsbConfig( cfg );                       // ÉèÖÃUSBÉè±¸ÅäÖÃ
 728   5                          if ( s == ERR_SUCCESS )
 729   5                          {
 730   6                              //Ðè±£´æ¶ËµãÐÅÏ¢ÒÔ±ãÖ÷³ÌÐò½øÐÐUSB´«Êä
 731   6                              ThisUsbDev.DeviceStatus = ROOT_DEV_SUCCESS;
 732   6                              ThisUsbDev.DeviceType = USB_DEV_SUBCLASS_ADB;
 733   6                              SetUsbSpeed( 1 );                                            // Ä¬ÈÏÎªÈ«ËÙ
 734   6                              return( ERR_SUCCESS );                                       // Î´ÖªÉè±¸³õÊ¼»¯³É¹¦
 735   6                          }
 736   5                      }
 737   4                      else                                                                 // ¿ÉÒÔ½øÒ»²½·ÖÎö
 738   4                      {
 739   5                          s = CtrlSetUsbConfig( cfg );                                     // ÉèÖÃUSBÉè±¸ÅäÖÃ
 740   5                          if ( s == ERR_SUCCESS )
 741   5                          {
 742   6                              //Ðè±£´æ¶ËµãÐÅÏ¢ÒÔ±ãÖ÷³ÌÐò½øÐÐUSB´«Êä
 743   6                              ThisUsbDev.DeviceStatus = ROOT_DEV_SUCCESS;
 744   6                              ThisUsbDev.DeviceStatus = dv_cls ? dv_cls : if_cls;
 745   6                              SetUsbSpeed( 1 );                                            // Ä¬ÈÏÎªÈ«ËÙ
 746   6                              return( ERR_SUCCESS );                                       // Î´ÖªÉè±¸³õÊ¼»¯³É¹¦
 747   6                          }
 748   5                      }
 749   4                  }
 750   3              }
 751   2          }
 752   1      #if DE_PRINTF
 753   1          printf( "InitRootDev Err = %02X\n", (UINT16)s );
 754   1      #endif
 755   1          ThisUsbDev.DeviceStatus = ROOT_DEV_FAILED;
 756   1          SetUsbSpeed( 1 );                                                                 // Ä¬ÈÏÎªÈ«ËÙ
 757   1          t++;
 758   1          goto USBDevEnum;
 759   1      }
 760          /*******************************************************************************
 761          * Function Name  : EnumAllRootDevice
 762          * Description    : Ã¶¾ÙËùÓÐROOT-HUB¶Ë¿ÚµÄUSBÉè±¸
 763          * Input          : None
 764          * Output         : None
 765          * Return         : None
 766          *******************************************************************************/
 767          UINT8   EnumAllRootDevice( void )
 768          {
 769   1          UINT8I   s, RootHubIndex;
 770   1          RootHubIndex = 0;
 771   1      #if DE_PRINTF
 772   1          printf( "EnumAllRootDev\n" );
 773   1      #endif
 774   1      #if DE_PRINTF
 775   1          printf( "RootHubIndex %02x\n",(UINT16)RootHubIndex );
C51 COMPILER V9.52.0.0   USBHOST                                                           11/02/2017 16:18:18 PAGE 14  

 776   1      #endif
 777   1          if ( ThisUsbDev.DeviceStatus == ROOT_DEV_CONNECTED )                        // ¸Õ²åÈëÉè±¸ÉÐÎ´³õÊ¼»¯
 778   1          {
 779   2              s = InitRootDevice( RootHubIndex );                                      // ³õÊ¼»¯/Ã¶¾ÙÖ¸¶¨HUB¶Ë¿Ú
             -µÄUSBÉè±¸
 780   2              if ( s != ERR_SUCCESS )
 781   2              {
 782   3                  return( s );
 783   3              }
 784   2          }
 785   1          return( ERR_SUCCESS );
 786   1      }
 787          /*******************************************************************************
 788          * Function Name  : SearchTypeDevice
 789          * Description    : ÔÚROOT-HUBÒÔ¼°Íâ²¿HUB¸÷¶Ë¿ÚÉÏËÑË÷Ö¸¶¨ÀàÐÍµÄÉè±¸ËùÔÚµÄ¶Ë¿ÚºÅ,Êä³ö¶Ë¿ÚºÅÎª0xFFFFÔòÎ´ËÑË÷µ
             -½
 790          * Input          : UINT8 type ËÑË÷µÄÉè±¸ÀàÐÍ
 791          * Output         : None
 792          * Return         : Êä³ö¸ß8Î»ÎªROOT-HUB¶Ë¿ÚºÅ,µÍ8Î»ÎªÍâ²¿HUBµÄ¶Ë¿ÚºÅ,µÍ8Î»Îª0ÔòÉè±¸Ö±½ÓÔÚROOT-HUB¶Ë¿ÚÉÏ
 793                             µ±È»Ò²¿ÉÒÔ¸ù¾ÝUSBµÄ³§ÉÌVID²úÆ·PID½øÐÐËÑË÷(ÊÂÏÈÒª¼ÇÂ¼¸÷Éè±¸µÄVIDºÍPID),ÒÔ¼°Ö¸¶¨ËÑË÷ÐòºÅ
 794          *******************************************************************************/
 795          UINT16  SearchTypeDevice( UINT8 type )
 796          {
 797   1          UINT8   RootHubIndex, HubPortIndex;
 798   1          for ( RootHubIndex = 0; RootHubIndex != 2; RootHubIndex ++ )                      // ÏÖÊ±ËÑË÷¿ÉÒÔ±ÜÃâÉ
             -è±¸ÖÐÍ¾°Î³ö¶øÄ³Ð©ÐÅÏ¢Î´¼°Ê±¸üÐÂµÄÎÊÌâ
 799   1          {
 800   2              if ( ThisUsbDev.DeviceType == type && ThisUsbDev.DeviceStatus >= ROOT_DEV_SUCCESS )
 801   2              {
 802   3                  return( (UINT16)RootHubIndex << 8 );                                      // ÀàÐÍÆ¥ÅäÇÒÃ¶¾Ù³É¹
             -¦,ÔÚROOT-HUB¶Ë¿ÚÉÏ
 803   3              }
 804   2              if ( ThisUsbDev.DeviceType == USB_DEV_CLASS_HUB && ThisUsbDev.DeviceStatus >= ROOT_DEV_SUCCESS )//
             - Íâ²¿¼¯ÏßÆ÷HUBÇÒÃ¶¾Ù³É¹¦
 805   2              {
 806   3                  for ( HubPortIndex = 1; HubPortIndex <= ThisUsbDev.GpVar[0]; HubPortIndex ++ )// ËÑË÷Íâ²¿HUBµÄ
             -¸÷¸ö¶Ë¿Ú
 807   3                  {
 808   4                      if ( DevOnHubPort[HubPortIndex-1].DeviceType == type && DevOnHubPort[HubPortIndex-1].Devic
             -eStatus >= ROOT_DEV_SUCCESS )
 809   4                      {
 810   5                          return( ( (UINT16)RootHubIndex << 8 ) | HubPortIndex );           // ÀàÐÍÆ¥ÅäÇÒÃ¶¾Ù³É¹
             -¦
 811   5                      }
 812   4                  }
 813   3              }
 814   2          }
 815   1          return( 0xFFFF );
 816   1      }
 817          /*******************************************************************************
 818          * Function Name  : InitUSB_Host
 819          * Description    : ³õÊ¼»¯USBÖ÷»ú
 820          * Input          : None
 821          * Output         : None
 822          * Return         : None
 823          *******************************************************************************/
 824          void    InitUSB_Host( void )
 825          {
 826   1          UINT8   i;
 827   1          IE_USB = 0;
 828   1      //  LED_CFG = 1;
 829   1      //  LED_RUN = 0;
C51 COMPILER V9.52.0.0   USBHOST                                                           11/02/2017 16:18:18 PAGE 15  

 830   1          USB_CTRL = bUC_HOST_MODE;                                                    // ÏÈÉè¶¨Ä£Ê½
 831   1          UHOST_CTRL &= ~bUH_PD_DIS;                                                   //ÆôÓÃÖ÷»úÏÂÀ­
 832   1          USB_DEV_AD = 0x00;
 833   1          UH_EP_MOD = bUH_EP_TX_EN | bUH_EP_RX_EN ;
 834   1          UH_RX_DMA = RxBuffer;
 835   1          UH_TX_DMA = TxBuffer;
 836   1          UH_RX_CTRL = 0x00;
 837   1          UH_TX_CTRL = 0x00;
 838   1          USB_CTRL = bUC_HOST_MODE | bUC_INT_BUSY;// | bUC_DMA_EN;                        // Æô¶¯USBÖ÷»ú¼°DMA,ÔÚ
             -ÖÐ¶Ï±êÖ¾Î´Çå³ýÇ°×Ô¶¯ÔÝÍ£
 839   1      //  UHUB0_CTRL = 0x00;
 840   1      //  UHUB1_CTRL = 0x00;
 841   1      //     UH_SETUP = bUH_SOF_EN;
 842   1          USB_INT_FG = 0xFF;                                                           // ÇåÖÐ¶Ï±êÖ¾
 843   1          for ( i = 0; i != 2; i ++ )
 844   1          {
 845   2              DisableRootHubPort( );                                                   // Çå¿Õ
 846   2          }
 847   1          USB_INT_EN = bUIE_TRANSFER | bUIE_DETECT;
 848   1      //  IE_USB = 1;                                                                  // ²éÑ¯·½Ê½
 849   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2599    ----
   CONSTANT SIZE    =    309    ----
   XDATA SIZE       =   ----      30
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----       2
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
